---

# 히스토그램에서 가장 큰 직사각형

## 문제 이해

히스토그램의 각 막대 높이가 주어졌을 때, 인접한 막대들을 이용하여 만들 수 있는 **가장 큰 직사각형의 넓이**를 구하는 문제이다.
각 테스트 케이스는 막대기의 개수 `N`과 그에 해당하는 `N`개의 높이가 입력되며, `N = 0`일 경우 입력이 종료된다.

---

## 아이디어

1. **Stack을 이용한 해결 방식**

   * 막대의 인덱스를 스택에 저장하며 **높이가 증가하는 구간을 유지**한다.
   * 현재 막대의 높이가 이전보다 낮아지는 순간, 스택에서 pop한 막대를 기준으로 직사각형 넓이를 계산한다.
   * 넓이 계산 시, pop된 막대가 가장 낮은 높이 역할을 하며, 그 막대가 포함될 수 있는 가능한 최대 너비를 계산한다.
2. 모든 막대를 다 처리한 뒤, **스택에 남은 막대들도 동일하게 넓이를 계산**한다.

---

## 주요 자료구조

| 이름         | 자료형              | 설명                          |
| ---------- | ---------------- | --------------------------- |
| `height`   | `long[]`         | 각 막대의 높이 정보 저장              |
| `stack`    | `Stack<Integer>` | 막대 인덱스를 저장 (높이가 증가하는 구간 유지) |
| `max_area` | `long`           | 지금까지 계산된 최대 넓이              |
| `i`        | `int`            | 현재 탐색 중인 막대 위치              |

---

## 알고리즘 흐름

### `getArea()`

1. `i = 0`부터 시작하여 모든 막대를 탐색한다.
2. 스택이 비어 있거나 현재 막대의 높이가 스택 top 막대보다 크면 스택에 push한다.
3. 현재 막대의 높이가 감소하면, 스택에서 pop하여 직사각형의 넓이를 계산한다.

   * 높이는 `height[top]`
   * 너비는

     * 스택이 비었으면 `i`
     * 아니면 `i - stack.peek() - 1`
4. 모든 막대 탐색 후에도 스택이 비어 있을 때까지 앞의 방식으로 넓이를 계산한다.

---

## 핵심 계산 방식

| 상태                | 계산 방식                                         |
| ----------------- | --------------------------------------------- |
| `stack.isEmpty()` | `area = height[top] * i`                      |
| `stack이 비어있지 않음`  | `area = height[top] * (i - stack.peek() - 1)` |

---


