## 문제 이해
* 교실은 N*N의 격자 나타낼 수 있고 (r, c)는 r행 c열을 의미한다. 
* 학생은 1번부터 N^2번까지 번호가 매겨져 있다.
* 학생의 번호와 그 학생이 좋아하는 학생 4명의 번호가 주어진다.
* 다음과 같은 규칙을 이용해 정해진 순서대로 학생의 자리를 정하려고 한다.
* 한 칸에는 학생 한 명의 자리만 있을 수 있고, |r1 - r2| + |c1 - c2| = 1을 만족하는 두 칸이 (r1, c1)과 (r2, c2)를 인접한다고 한다.

* 1. 비어있는 칸 중에서 좋아하는 학생이 인접한 칸에 가장 많은 칸으로 자리를 정한다.
* 2. 1을 만족하는 칸이 여러 개이면, 인접한 칸 중에서 비어있는 칸이 가장 많은 칸으로 자리를 정한다.
* 3. 2를 만족하는 칸도 여러 개인 경우에는 행의 번호가 가장 작은 칸으로, 그러한 칸도 여러 개이면 열의 번호가 가장 작은 칸으로 자리를 정한다.

* 최종적으로 학생의 만족도를 구한다.
* 학생의 만족도를 구하려면 그 학생과 인접한 칸에 앉은 좋아하는 학생의 수를 구해야 한다.
* 그 값이 0이면 학생의 만족도는 0, 1이면 1, 2이면 10, 3이면 100, 4이면 1000이다.

## 아이디어
1. 완전탐색, Map
2. 자리의 정보에 대한 Class생성. 자리배치 Method 구현.
## 구현
### 상태
* `Seat` : 자리에 대한 정보를 저장할 Class. 자리의 좌표, 자리에 인접한 빈자리의 수, 자리에 인접한 좋아하는 친구의 수를 저장한다.
* `graph` : 현재 교실의 배치 상태(2차원 배열). (0이면 빈자리)
* `love` : HashMap<Integer,int[]>  Key : 학생의 번호 , Value : 학생이 좋아하는 학생 번호 
* `putStudentSeat` : 학생을 교실에 자리배치 하는 Method
* `getScore` : 만족도를 조사하는 Method
  

### 탐색
* `putStudentSeat`의 파라미터에 교실에 배치할 학생의 번호를 넘겨준다.
* `freinds` 배열에 해당 학생의 좋아하는 학생들을 넣어준다.
* 전체 좌표를 탐색하며 해당 좌표가 비어있다면, 그 좌표의 주변을 분석하여 empty정보와 friend정보를 `Seat seat`객체에 넣어서 `ArrayList<Seat> seats`에 넣어준다.
* 모든 좌표를 탐색했다면, `Seats`리스트를 문제 조건에 맞게 정렬한다.
* 정렬 후 가장 첫번째 객체 `seat`이 해당 학생의 자리이다.
* 이를 모든 학생에 대하여 진행한다.
* 자리 배치가 끝났다면 `getScore` Method로 최종 만족도를 구한다.
* 모든 좌표에 대하여 인접한 좋아하는 친구의 수를 구하여서 10의 (cnt-1)제곱으로 만족도를 계산하여 `score`에 더해준다.
* 최종 `score`을 반환하여 출력한다.
