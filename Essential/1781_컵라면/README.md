# 컵라면 (Greedy + Priority Queue)

## 문제 이해

문제는 **마감 기한(deadline)** 과 **보상(cup, 컵라면 수)** 를 가진다.
하루에 한 문제만 풀 수 있으며, 마감일까지 문제를 풀면 해당 보상을 받을 수 있다.
N개의 문제 중에서 **얻을 수 있는 컵라면의 총합을 최대화**해야 한다.

각 문제는 `(deadline, cup)` 형태로 주어지며,
문제를 선택하는 순서를 최적으로 조절하여 최댓값을 구하는 것이 목표이다.

---

## 아이디어

1. **문제를 deadline 기준 오름차순으로 정렬**한다.
   (만약 deadline이 같으면 보상(cup)이 큰 문제를 먼저)
2. 정렬된 순서대로 문제를 하나씩 선택한다.
3. 선택한 문제들의 보상을 **최소힙(PriorityQueue)** 에 넣어 관리한다.
4. 어떤 시점에서 선택된 문제의 개수가 `현재 문제의 deadline` 을 초과하면
   → **보상이 가장 적은 문제를 제거**하여 최적 상태를 유지한다.
5. 결국 힙에 남는 문제들의 보상 합이 최대 보상이다.

---

## 주요 자료구조

| 이름       | 자료형                      | 설명                                  |
| -------- | ------------------------ | ----------------------------------- |
| `pq`     | `PriorityQueue<Ramen>`   | 문제(deadline, cup)를 정렬하여 관리하는 우선순위 큐 |
| `result` | `PriorityQueue<Integer>` | 선택된 문제들의 보상을 저장하는 최소힙               |
| `Ramen`  | `class`                  | deadline, cup 정보를 담고 비교 기준 지정       |

---

## 메서드 설명

### `compareTo(Ramen o)`

* 문제 정렬 기준을 정의한다.
* 1순위: `deadline` 오름차순
* 2순위: 보상 `cup` 내림차순
  → 같은 마감일이면 보상이 큰 문제를 먼저 선택하도록 한다.

### 그리디 로직

1. 정렬된 문제를 하나씩 힙(result)에 넣는다.
2. 현재 힙의 크기 > deadline이면
   → 가장 작은 보상을 가진 문제를 제거하여 더 큰 문제들을 선택할 기회를 확보한다.
3. 최종적으로 힙에 남아 있는 값들의 합을 출력한다.
