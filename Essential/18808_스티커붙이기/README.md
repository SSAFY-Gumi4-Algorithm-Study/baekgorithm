## 문제 이해

노트북의 크기 ( N \times M )과 ( K )개의 스티커가 주어진다.
각 스티커는 1과 0으로 이루어진 2차원 배열이며, 1은 스티커의 붙일 수 있는 부분을 의미한다.
스티커는 다음 규칙에 따라 붙인다.

1. 스티커는 시계 방향으로 90도씩 최대 3번 회전할 수 있다.
2. 회전 후에도 노트북 범위를 벗어나지 않아야 한다.
3. 이미 다른 스티커가 붙은 칸(값이 1인 칸)에는 겹쳐 붙일 수 없다.
4. 스티커를 붙일 수 있는 위치가 여러 곳이면, 가장 위쪽, 그중에서도 가장 왼쪽 위치에 붙인다.
5. 모든 스티커를 차례대로 처리한 뒤, 노트북에 붙은 스티커의 칸(1의 개수)을 출력한다.

---

## 아이디어

* 각 스티커마다 **4가지 회전 상태(0°, 90°, 180°, 270°)** 를 시도한다.
* 각 회전 상태에서 노트북의 모든 위치를 탐색하여 **붙일 수 있는지(canAttach)** 를 확인한다.
* 가능한 위치가 있다면 **붙이고(attachSticker)** 다음 스티커로 넘어간다.
* 모든 스티커가 처리된 후, 최종적으로 노트북의 1의 개수를 세어 결과를 출력한다.

핵심 아이디어는 완전 탐색(Brute Force) 기반으로,
스티커를 회전시키면서 가능한 위치를 모두 확인하는 방식이다.

---

## 구현

### 상태

* `int N, M, K` : 노트북 행, 열, 스티커 개수
* `int[][] notebook` : 노트북 상태를 나타내는 2차원 배열 (0 = 빈 칸, 1 = 스티커 붙은 칸)
* 각 스티커는 `int[][] sticker` 형태로 입력받는다.

---

### 탐색

1. **입력 처리**

   * 각 스티커의 행(R), 열(C)을 입력받고, 2차원 배열로 저장한다.
2. **회전 탐색 (`rotateSticker`)**

   * 주어진 스티커를 시계 방향으로 90도 회전시키는 함수를 구현한다.
   * 새로운 배열 `rotated[j][R - 1 - i] = sticker[i][j]` 형태로 변환.
3. **붙이기 시도 (`tryAttach`)**

   * 현재 스티커 상태로 노트북의 모든 위치(i, j)에 대해
     붙일 수 있는지(`canAttach`) 검사한다.
   * 붙일 수 있다면 `attachSticker` 호출 후 `true` 반환.
4. **조건 검사 (`canAttach`)**

   * 스티커의 각 칸이 1인 경우, 노트북의 해당 위치가 이미 1이라면 `false`.
5. **스티커 부착 (`attachSticker`)**

   * 가능한 위치에 도달하면, 노트북의 해당 칸을 1로 변경.
6. **최종 결과 계산**

   * 모든 스티커 처리 후, `notebook` 전체를 순회하여 1의 개수를 세어 출력.

---


